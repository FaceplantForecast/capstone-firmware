/**
 *   @file  mmwave.h
 *
 *   @brief
 *      This is the high level API which is used to abstract the mmWave
 *      link API and allow application developers to be abstracted from
 *      the lower level complexities.
 *
 *  \par
 *  NOTE:
 *      (C) Copyright 2016-2025 Texas Instruments, Inc.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/** @defgroup MMWAVE      mmWave API
 */
#ifndef MMWAVE_H
#define MMWAVE_H

/* mmWave SDK Include Files: */
#include <C:/ti/mmwave_mcuplus_sdk_04_07_01_04/mmwave_dfp_02_04_18_01/ti/control/mmwavelink/mmwavelink.h>

#include <C:/ti/mmwave_mcuplus_sdk_04_07_01_04/mmwave_mcuplus_sdk_04_07_01_04/ti/common/mmwave_error.h>
#include <C:/ti/mmwave_mcuplus_sdk_04_07_01_04/mcu_plus_sdk_awr294x_10_01_00_04/source/drivers/crc.h>

#if defined (SOC_AWR294X)
#include <drivers/hw_include/awr294x/soc_config.h>
#include <drivers/mailbox.h>
#endif

#if defined (SOC_AWR2544)
#include <drivers/hw_include/awr2544/soc_config.h>
#include <drivers/mailbox.h>
#endif

#if defined (SOC_AWR2X44P)
#include <drivers/hw_include/awr2x44p/soc_config.h>
#include <drivers/mailbox.h>
#endif

/**
@defgroup MMWAVE_CTRL_EXTERNAL_FUNCTION            mmWave External Functions
@ingroup MMWAVE
@brief
*   The section has a list of all the exported API which the applications need to
*   invoke in order to use the driver
*/
/**
@defgroup MMWAVE_EXTERNAL_DATA_STRUCTURE      mmWave External Data Structures
@ingroup MMWAVE
@brief
*   The section has a list of all the data structures which are exposed to the
*   application
*/
/**
@defgroup MMWAVE_EXTERNAL_DEFINITIONS      mmWave External Defintions
@ingroup MMWAVE
@brief
*   The section has a list of all external definitions which are exposed by the
*   mmWave module.
*/
/**
@defgroup MMWAVE_ERROR_CODE                   mmWave Error Codes
@ingroup MMWAVE
@brief
*   The section has a list of all the error codes which are generated by the module
*/
/**
@defgroup MMWAVE_INTERNAL_FUNCTION            mmWave Internal Functions
@ingroup MMWAVE
@brief
*   The section has a list of all internal API which are not exposed to the external
*   applications.
*/
/**
@defgroup MMWAVE_INTERNAL_DATA_STRUCTURE      mmWave Internal Data Structures
@ingroup MMWAVE
@brief
*   The section has a list of all internal data structures which are used internally
*   by the mmWave module.
*/
/**
@defgroup MMWAVE_INTERNAL_DEFINITIONS      mmWave Internal Defintions
@ingroup MMWAVE
@brief
*   The section has a list of all internal definitions which are used internally
*   by the mmWave module.
*/

#ifdef __cplusplus
extern "C" {
#endif

/** @addtogroup MMWAVE_ERROR_CODE
 *  Base error code for the mmWave module is defined in the
 *  \include ti/common/mmwave_error.h
 @{ */

/**
 * @brief   Error Code: Invalid argument
 */
#define MMWAVE_EINVAL                   (MMWAVE_ERRNO_BASE-1)

/**
 * @brief   Error Code: mmWave link initialization failed
 */
#define MMWAVE_EINIT                    (MMWAVE_ERRNO_BASE-2)

/**
 * @brief   Error Code: mmWave link not supported
 */
#define MMWAVE_ENOTSUP                  (MMWAVE_ERRNO_BASE-3)

/**
 * @brief   Error Code: mmWave link channel configuration failed
 */
#define MMWAVE_ECHCFG                   (MMWAVE_ERRNO_BASE-4)

/**
 * @brief   Error Code: mmWave link ADC configuration failed
 */
#define MMWAVE_EADCCFG                  (MMWAVE_ERRNO_BASE-5)

/**
 * @brief   Error Code: mmWave link Power configuration failed
 */
#define MMWAVE_EPOWERCFG                (MMWAVE_ERRNO_BASE-6)

/**
 * @brief   Error Code: mmWave link RF initialization failed
 */
#define MMWAVE_ERFINIT                  (MMWAVE_ERRNO_BASE-7)

/**
 * @brief   Error Code: mmWave link profile configuration failed
 */
#define MMWAVE_EPROFILECFG              (MMWAVE_ERRNO_BASE-8)

/**
 * @brief   Error Code: mmWave link chirp configuration failed
 */
#define MMWAVE_ECHIRPCFG                (MMWAVE_ERRNO_BASE-9)

/**
 * @brief   Error Code: mmWave link frame configuration failed
 */
#define MMWAVE_EFRAMECFG                (MMWAVE_ERRNO_BASE-10)

/**
 * @brief   Error Code: mmWave link PLL caliberation failed
 */
#define MMWAVE_EPLLCFG                  (MMWAVE_ERRNO_BASE-11)

/**
 * @brief   Error Code: mmWave link sensor failed
 */
#define MMWAVE_ESENSOR                  (MMWAVE_ERRNO_BASE-12)

/**
 * @brief   Error Code: OS Porting layer services failed
 */
#define MMWAVE_EOS                      (MMWAVE_ERRNO_BASE-13)

/**
 * @brief   Error Code: mmWave Link version error
 */
#define MMWAVE_EVERSION                 (MMWAVE_ERRNO_BASE-14)

/**
 * @brief   Error Code: mmWave message processing error
 */
#define MMWAVE_EMSG                     (MMWAVE_ERRNO_BASE-15)

/**
 * @brief   Error Code: mmWave deinitialization error
 */
#define MMWAVE_EDEINIT                  (MMWAVE_ERRNO_BASE-16)

/**
 * @brief   Error Code: mmWave continuous mode configuration failed
 */
#define MMWAVE_ECONTMODECFG             (MMWAVE_ERRNO_BASE-17)

/**
 * @brief   Error Code: mmWave continuous mode enabling failed
 */
#define MMWAVE_ECONTMODE                (MMWAVE_ERRNO_BASE-18)

/**
 * @brief   Error Code: mmWave link BSS calibration configuration failed
 */
#define MMWAVE_ECALCFG                  (MMWAVE_ERRNO_BASE-19)

/**
 * @brief   Error Code: mmWave link BSS calibration init
 */
#define MMWAVE_ECALINIT                 (MMWAVE_ERRNO_BASE-20)

/**
 * @brief   Error Code: mmWave link BSS calibration periodicity failed
 */
#define MMWAVE_ECALPERIOD               (MMWAVE_ERRNO_BASE-21)

/**
 * @brief   Error Code: mmWave link BSS calibration trigger failed
 */
#define MMWAVE_ECALTRIG                 (MMWAVE_ERRNO_BASE-22)

/**
 * @brief   Error Code: Out of memory error
 */
#define MMWAVE_ENOMEM                   (MMWAVE_ERRNO_BASE-23)

/**
 * @brief   Error Code: Not found
 */
#define MMWAVE_ENOTFOUND                (MMWAVE_ERRNO_BASE-24)

/**
 * @brief   Error Code: Asynchronous event configuration failed
 */
#define MMWAVE_EASYNCEVENT              (MMWAVE_ERRNO_BASE-25)

/**
 * @brief   Error Code: Calibration failed.
 */
#define MMWAVE_ECALFAIL                 (MMWAVE_ERRNO_BASE-26)

/**
 * @brief   Error Code: mmWave link BPM common configuration failed
 */
#define MMWAVE_ECOMMONBPMCFG            (MMWAVE_ERRNO_BASE-27)

/**
 * @brief   Error Code: mmWave link BPM configuration failed
 */
#define MMWAVE_EBPMCFG                  (MMWAVE_ERRNO_BASE-28)

/**
 * @brief   Error Code: invalid value provided for calibMonTimeUnit
 * in MMWave_open() failed
 */
#define MMWAVE_EINVALIDCALMONUNIT       (MMWAVE_ERRNO_BASE-29)

/**
 * @brief   Error Code: Phase shift Calibration data restore failed.
 */
#define MMWAVE_EPHASESHIFTCALDATARESTOREFAIL    (MMWAVE_ERRNO_BASE-30)

/**
 * @brief   Error Code: mmWave link datapath configuration failed
 */
#define MMWAVE_EDATAPATHCFG                  (MMWAVE_ERRNO_BASE-31)

/**
 * @brief   Error Code: mmWave link data path clock configuration failed
 */
#define MMWAVE_EDATAPATHCLOCKCFG             (MMWAVE_ERRNO_BASE-32)

/**
 * @brief   Error Code: mmWave link HSI clock configuration failed
 */
#define MMWAVE_EHSICLKCFG                    (MMWAVE_ERRNO_BASE-33)

/**
 * @brief   Error Code: mmWave link CSI configuration failed
 */
#define MMWAVE_ECSI2CFG                      (MMWAVE_ERRNO_BASE-34)

/**
 * @brief   Error Code: mmWave link Lane configuration failed
 */
#define MMWAVE_ELANECFG                      (MMWAVE_ERRNO_BASE-35)

/**
 * @brief   Error Code: mmWave link data format configuration failed
 */
#define MMWAVE_EDATAFMTCFG                   (MMWAVE_ERRNO_BASE-36)

/**
 * @brief   Error Code: mmWave link internal configuration failed
 */
#define MMWAVE_EINTERNALCFG                   (MMWAVE_ERRNO_BASE-37)

/**
 * @brief   Error Code: mmWave link RF enable  failed
 */
#define MMWAVE_ERFEN                          (MMWAVE_ERRNO_BASE-38)

/**
 * @brief   Error Code: mmWave link Miscelaneous config  failed
 */
#define MMWAVE_EMISCCFG                       (MMWAVE_ERRNO_BASE-39)

 /**
  * @brief   Error Code: mmWave link chirp level phase shifter failed
  */
#define MMWAVE_EPHASESHIFTCFG                (MMWAVE_ERRNO_BASE-40)

/**
 * @brief   Error Code: mmWave link advance chirp param configuration failed
 */
#define MMWAVE_EADVCHIRPCFG                  (MMWAVE_ERRNO_BASE-41)

/**
 * @brief   Error Code: mmWave link LUT buffer filling failed
 */
#define MMWAVE_EFillLUTBUF                   (MMWAVE_ERRNO_BASE-42)
/**
@}
*/

#define MMWAVE_RADAR_DEVICES                  (1U)

/** @addtogroup MMWAVE_EXTERNAL_DEFINITIONS
 @{ */

/**
 * @brief
 *  mmWave Supported max profiles which can be configured on the BSS
 */
#define   MMWAVE_MAX_PROFILE                (4U)

/**
 * @brief
 *  This is the ACK wait timeout in msec. This is the time for which the
 *  mmWave link module will wait for the reception on an ACK from the BSS. If
 *  this is set to 0 then the mmWave link will not wait for an ACK.
 */
#define   MMWAVE_ACK_TIMEOUT                (1000U)

/**
 * @brief maximum local LUT buffer space for each parameter
 */
#define   MMWAVE_EACH_CHIRP_PARAM_MAX_LUT_BUF_SIZE   (256U)


/**
 * @brief number of advance chirp parameters
 */
#define   MMWAVE_ADVANCE_CHIRP_NUM_PARAMS   (11U)

/**
@}
*/

/** @addtogroup MMWAVE_EXTERNAL_DATA_STRUCTURE
 @{ */

/**
 * @brief
 *  mmWave Profile Handle
 */
typedef void*   MMWave_ProfileHandle;

/**
 * @brief
 *  mmWave Chirp Handle
 */
typedef void*   MMWave_ChirpHandle;

/**
 * @brief
 *  mmWave Advanced chirp Handle
 */
typedef void*   MMWave_AdvChirpHandle;

/**
 * @brief
 * mmWave LUT Data Handle
 */
typedef void*   MMWave_LUTDataHandle;

/**
 * @brief
 *  mmWave BPM configuration Handle
 */
typedef void*   MMWave_BpmChirpHandle;

/**
 * @brief
 *  mmWave chirp level phase shifter configuration Handle
 */
typedef void*   MMWave_PhaseShiftChirpHandle;

/**
 * @brief
 *  Error Level
 *
 * @details
 *  The mmWave module API can return different error levels. The enumeration
 *  describes different error levels. Please refer to the MMWave error decode
 *  function on the interpretation of this error level.
 *
 *  @sa
 *      MMWave_decodeError
 */
typedef enum MMWave_ErrorLevel_e
{
    /**
     * @brief   The mmWave API was successful. There were no errors detected.
     * There is no reason to perform any error decode here.
     */
    MMWave_ErrorLevel_SUCCESS   = 0,

    /**
     * @brief   The mmWave API reported a warning. Application can either ignore this
     * error message *OR* can perform the error decoding to get more information
     * on the actual reason.
     */
    MMWave_ErrorLevel_WARNING,

    /**
     * @brief   The mmWave API reported an error and applications should perform
     * error decoding to get the exact reason for the failure.
     */
    MMWave_ErrorLevel_ERROR
}MMWave_ErrorLevel;

/**
 * @brief
 *  DFE Data Output Mode
 *
 * @details
 *  The enumeration describes the mode in which the DFE outputs the data
 */
typedef enum MMWave_DFEDataOutputMode_e
{
    /**
     * @brief   The DFE is operating in Frame mode
     */
    MMWave_DFEDataOutputMode_FRAME      = 0xA0000000U,

    /**
     * @brief   The DFE is operating in continuous mode
     */
    MMWave_DFEDataOutputMode_CONTINUOUS,

    /**
     * @brief   The DFE is operating in advanced frame mode
     */
    MMWave_DFEDataOutputMode_ADVANCED_FRAME,

    /**
     * @brief   The DFE is operating in advanced chirp with normal frame mode
     */
    MMWave_DFEDataOutputMode_ADVANCED_CHIRP_LEGACY_FRAME,

        /**
     * @brief   The DFE is operating in advanced chirp with advanced frame mode
     */
    MMWave_DFEDataOutputMode_ADVANCED_CHIRP_ADVANCED_FRAME
}MMWave_DFEDataOutputMode;

/**
 * @brief
 *  Default Asynchronous Event Handler
 *
 * @details
 *  Enumeration describes the entity which is responsible for the reception
 *  of asynchronous events from the BSS. By default the BSS assumes that the
 *  MSS is the recepient of asynchronous events such as CPU & ESM Faults etc.
 */
typedef enum MMWave_DefaultAsyncEventHandler_e
{
    /**
     * @brief   The MSS is the default handler for the asynchronous event
     */
    MMWave_DefaultAsyncEventHandler_MSS,

    /**
     * @brief   The DSS is the default handler for the asynchronous event
     *          Not a vallid option for xwr14xx/xwr64xx device
     */
    MMWave_DefaultAsyncEventHandler_DSS
}MMWave_DefaultAsyncEventHandler;

/**
 * @brief
 *  Chirp Calibration configuration
 *
 * @details
 *  The structure is used to hold the information which is required
 *  to setup the calibration of the RF while operating in the Chirp
 *  mode
 */
typedef struct MMWave_ChirpCalibrationCfg_t
{
    /**
     * @brief   Flag which determines if calibration is to be enabled or
     * not.
     */
    bool            enableCalibration;

    /**
     * @brief   Flag which determines if periodic calibration is to be enabled or
     * not. The mmWave will always do one time calibration.
     */
    bool            enablePeriodicity;

    /**
     * @brief   This is valid only if periodicity is enabled and is the time in frames
     * when a calibration report is received by the application through an asynchrous
     * event.
     */
    uint16_t        periodicTimeInFrames;

    /**
     * @brief   Flag to enable/disable the calibration report.
     */
    uint8_t          reportEn;
}MMWave_ChirpCalibrationCfg;

/**
 * @brief
 *  Continuous Calibration configuration
 *
 * @details
 *  The structure is used to hold the information which is required
 *  to setup the calibration of the RF while operating in continuous
 *  mode
 */
typedef struct MMWave_ContCalibrationCfg_t
{
    /**
     * @brief   In continuous mode; only one shot calibration is supported
     * Set this flag to enable this feature.
     */
    bool            enableOneShotCalibration;

    /**
     * @brief   Flag to enable/disable the calibration report.
     */
    uint8_t         reportEn;
}MMWave_ContCalibrationCfg;

/**
 * @brief
 *  Calibration configuration
 *
 * @details
 *  The structure is used to hold the information which is required
 *  to setup the calibration of the RF
 */
typedef struct MMWave_CalibrationCfg_t
{
    /**
     * @brief   DFE Data Output Mode: Chirp or Continuous
     *
     * NOTE: Please ensure that the DFE Data output mode passed during
     * control configuration and calibration configuration should be
     * the same. Failure to do so will result in unpredictable behavior
     */
    MMWave_DFEDataOutputMode        dfeDataOutputMode;

    union
    {
        /**
         * @brief   This should be configured if the DFE Data output mode
         * is configured to operate in frame or advanced frame mode
         */
        MMWave_ChirpCalibrationCfg  chirpCalibrationCfg;

        /**
         * @brief   This should be configured if the DFE Data output mode
         * is configured to operate in continuous mode
         */
        MMWave_ContCalibrationCfg   contCalibrationCfg;
    }u;
}MMWave_CalibrationCfg;

/**
 * @brief
 *  Frame mode configuration
 *
 * @details
 *  The structure specifies the configuration which is required to configure
 *  the mmWave link to operate in frame mode
 */
typedef struct MMWave_FrameCfg_t
{
    /**
     * @brief   List of all the active profile handles which can be configured.
     * Setting to NULL indicates that the profile is skipped.
     */
    MMWave_ProfileHandle    profileHandle[MMWAVE_MAX_PROFILE];

    /**
     * @brief   Configuration which is used to setup Frame
     */
    rlFrameCfg_t            frameCfg;
}MMWave_FrameCfg;

/**
 * @brief
 *  Advanced frame configuration
 *
 * @details
 *  The structure specifies the configuration which is required to configure
 *  the mmWave link to operate in advanced frame mode
 */
typedef struct MMWave_AdvancedFrameCfg_t
{
    /**
     * @brief   List of all the active profile handles which can be configured.
     * Setting to NULL indicates that the profile is skipped.
     */
    MMWave_ProfileHandle    profileHandle[MMWAVE_MAX_PROFILE];

    /**
     * @brief   Advanced Frame configuration
     */
    rlAdvFrameCfg_t         frameCfg;
}MMWave_AdvancedFrameCfg;

/**
 * @brief
 *  Continuous mode configuration
 *
 * @details
 *  The structure specifies the configuration which is required to configure
 *  the mmWave link to operate in continuous mode
 */
typedef struct MMWave_ContModeCfg_t
{
    /**
     * @brief   Continuous mode configuration
     */
    rlContModeCfg_t         cfg;

    /**
     * @brief   Sample count: This refers to the number of samples per
     * channel.
     */
    uint16_t                dataTransSize;
}MMWave_ContModeCfg;

/**
 * @brief
 *  Control configuration
 *
 * @details
 *  The structure specifies the configuration which is required to configure
 *  and setup the BSS.
 */
typedef struct MMWave_CtrlCfg_t
{
    /**
     * @brief   DFE Data Output Mode:
     */
    MMWave_DFEDataOutputMode        dfeDataOutputMode;

    /**
     * @brief   Number of Phase Shifter Chirps for each device.
     */
    uint32_t                        numOfPhaseShiftChirps[MMWAVE_RADAR_DEVICES];

    union
    {
        /**
         * @brief   Chirp configuration to be used: This is only applicable
         * if the data output mode is set to Chirp
         */
        MMWave_FrameCfg             frameCfg[MMWAVE_RADAR_DEVICES];

        /**
         * @brief   Continuous configuration to be used: This is only applicable
         * if the data output mode is set to Continuous
         */
        MMWave_ContModeCfg          continuousModeCfg[MMWAVE_RADAR_DEVICES];

        /**
         * @brief   Advanced Frame configuration: This is only applicable
         * if the data output mode is set to Advanced Frame
         */
        MMWave_AdvancedFrameCfg     advancedFrameCfg[MMWAVE_RADAR_DEVICES];
    }u;

    /**
     * @brief   Enable Programmable filter feature.
     */
    uint32_t                         enableProgFilter;

}MMWave_CtrlCfg;


/**
 * @brief
 *  Open Configuration
 *
 * @details
 *  The structure specifies the configuration which is required to open the
 *  MMWave module. Once the MMWave module has been opened the mmWave link
 *  to the BSS is operational.
 */
typedef struct MMWave_OpenCfg_t
{
    /**
     * @brief   Low Frequency Limit for calibrations:
     */
    uint16_t                    freqLimitLow;

    /**
     * @brief   High Frequency Limit for calibrations
     */
    uint16_t                    freqLimitHigh;

    /**
     * @brief   Low power mode configuration
     */
    rlLowPowerModeCfg_t         lowPowerMode;

    /**
     * @brief   Configuration which is used to setup ADC
     */
    rlAdcOutCfg_t               adcOutCfg;

    /**
     * @brief   Data path configuration
     */
    rlDevDataPathCfg_t  dataPathCfg;

    /**
     * @brief   Data path clock configuration
     */
    rlDevDataPathClkCfg_t dataPathClkCfg;

    /**
     * @brief   HSI clock configuration
     */
    rlDevHsiClk_t hsiClkCfg;

    /**
     * @brief   CSI2 configuration
     */
    rlDevCsi2Cfg_t csi2Cfg;

    /**
     * @brief   Lane configuration
     */
    rlDevLaneEnable_t laneEnCfg;

    /**
     * @brief  I/Q Swap selection for complex outputs \n
                  0 Sample interleave mode - I first \n
                  1 Sample interleave mode - Q first \n
                  others reserved \n
     */
    rlUInt8_t           iqSwapSel;

    /**
     * @brief  Channel interleaving of the samples stored in \n
                  the ADC buffer to be transferred out on the data path \n
                  0 - Interleaved \n
                  1 - Non Interleaved \n
                  others reserved \n
     */
    rlUInt8_t           chInterleave;

    /**
     * @brief   Designate the default asynchronous event handler. By default
     * the BSS assumes that the default asynchronous event handler is the MSS.
     */
    MMWave_DefaultAsyncEventHandler     defaultAsyncEventHandler;

    /**
     * @brief   Flag that determines if frame start async event is disabled.
     * For more information refer to the mmWave Link documentation for:-
     * - RL_RF_AE_FRAME_TRIGGER_RDY_SB
     * - rlSensorStart
     */
    bool                disableFrameStartAsyncEvent;

    /**
     * @brief   Flag that determines if frame stop async event is disabled.
     * For more information refer to the mmWave Link documentation for:-
     * - RL_RF_AE_FRAME_END_SB
     * - rlSensorStop
     */
    bool                disableFrameStopAsyncEvent;

    /**
     * @brief   Set the flag to enable the application to specify the calibration
     * mask which is to be used. If the flag is set to false the MMWave module will
     * default and enable all the calibrations.
     */
    bool                useCustomCalibration;

    /**
     * @brief   This is the custom calibration enable mask which is to be used and
     * is applicable only if the application has enabled "Custom Calibration"
     */
    uint32_t            customCalibrationEnableMask;

    /**
     * @brief   Calibration Monitor time unit configuration in units of frame.
     *          Value of 1 here means Calibration Monitor time unit = 1 frame duration.
     *          See rlRfCalMonTimeUntConf_t for details on this configuration.
     */
    rlUInt16_t          calibMonTimeUnit;

    /**
     * @brief   Configuration which is used to setup channel
     */
    rlChanCfg_t         chCfg;

}MMWave_OpenCfg;

/**
 * @brief
 *  Calibration Configuration
 *
 * @details
 *  The structure specifies the various calibration data that RadarSS needs
 *  in case user desires to restore the calibration using factory values instead
 *  of requesting RadarSS to calculate them on-the-fly.
 */
typedef struct MMWave_CalibrationData_t
{
    /**
     * @brief   Calibration data as received from RadarSS via rlRfCalibDataStore API
     */
    rlCalibrationData_t*            ptrCalibData;

    /**
     * @brief   Phase shifter calibration data as received from
     *          RadarSS via rlRfPhShiftCalibDataStore API
     */
    rlPhShiftCalibrationData_t*     ptrPhaseShiftCalibData;

} MMWave_CalibrationData;

/**
 *  @b Description
 *  @n
 *      Application registered callback function which hooks up with the mmWave Link
 *      events generated by the BSS. Please refer to the mmWave Link documentation
 *      on more information about these parameters.
 *
 *  @param[in]  msgId
 *      Message Identifier
 *  @param[in]  sbId
 *      Subblock identifier
 *  @param[in]  sbLen
 *      Length of the subblock
 *  @param[in]  payload
 *      Pointer to the payload buffer
 *
 */
typedef int32_t (*MMWave_eventFxn)(uint8_t devIndex, uint16_t msgId, uint16_t sbId, uint16_t sbLen, uint8_t *payload);

/**
 * @brief
 *  mmWave Handle
 */
typedef void*   MMWave_Handle;

/**
 * @brief
 *  Execution Domain
 *
 * @details
 *  Enumeration describes the execution domain for the mmWave
 */
typedef enum MMWave_Domain_e
{
    /**
     * @brief   The mmWave is executing in the MSS domain
     */
    MMWave_Domain_MSS = 0x1,

    /**
     * @brief   The mmWave is executing in the DSS domain
     */
    MMWave_Domain_DSS = 0x2
}MMWave_Domain;

/**
 * @brief
 *  Configuration Mode
 *
 * @details
 *  The mmWave API can be used in either of the following configuration
 *  modes.
 */
typedef enum MMWave_ConfigurationMode_e
{
    /**
     * @brief   Minimal configuration:
     *
     * In this mode the mmWave is responsible for the following:-
     * - Setting up the mmWave Link Transport to the BSS
     * - Start/Stop/Synch capability with the BSS & DSS(if applicable)
     * - Asynch BSS Event notification to the peer domain (if applicable)
     * - mmWave Link initialization
     * - *No* dynamic memory allocation
     *
     * The application is responsible for the following:-
     * - Using the mmWave Link to configure the BSS
     * - Configuration management for the Profile/Chirp and Frame
     * - Sending messages to the peer domain (if applicable)
     *
     * This mode is useful for advanced users.
     */
    MMWave_ConfigurationMode_MINIMAL = 0x1,

    /**
     * @brief   Full configuration:
     *
     * In this mode the mmWave is responsible for the following:-
     * - Setting up the mmWave Link Transport to the BSS
     * - Start/Stop/Synch capability with the BSS & DSS (if applicable)
     * - Asynch BSS Event notification to the peer domain (if applicable)
     * - mmWave Link initialization
     * - Using the mmWave Link to configure the BSS
     * - Configuration management for the Profile/Chirp and Frame
     * - Sending messages to the peer domain (if applicable)
     * - Dynamic memory allocation
     *
     * The application is only responsible for tracking mmWave
     * handles.
     *
     * This mode is useful for basic users.
     */
    MMWave_ConfigurationMode_FULL,
}MMWave_ConfigurationMode;


/**
 * @brief
 *  mmWave Link CRC configuration
 *
 * @details
 *  The structure is used to describe the CRC configuration. The mmWaveLink messages
 *  exchanged between the MSS/DSS and BSS have a checksum applied. The configuration
 *  determines if the checksum computation is to use the CRC Driver *OR* should the
 *  computation be done in the software.
 */
typedef struct MMWave_LinkCRCCfg_t
{
    /**
     * @brief   The field is base address of CRC module.
     */
    uint32_t         crcBaseAddr;

    /**
     * @brief   The field is valid only if the CRC Driver is being used else
     * this is ignored.
     */
    CRC_Channel_t     crcChannel;

    /**
     * @brief   Flag which if set is used to indicate that the CRC driver is
     * to be used to perform the CRC computation
     */
    uint32_t         useCRCDriver;
}MMWave_LinkCRCCfg;


/**
 * @brief
 *  Initial Configuration
 *
 * @details
 *  The structure specifies the configuration which is required to initialize
 *  and setup the mmWave module.
 */
typedef struct MMWave_InitCfg_t
{
    /**
     * @brief   Execution domain on which the mmWave module is executing.
     */
    MMWave_Domain               domain;

    /**
     * @brief   Application supplied asynchronous event handler. This is invoked
     * on the reception of an asynchronous event from the BSS
     */
    MMWave_eventFxn             eventFxn;

    /**
     * @brief   mmWave link messages exchanged with the BSS have a checksum. The
     * configuration specifies if the CRC hardware *or* software to be used for
     * checksum calculation and validation.
     */
    MMWave_LinkCRCCfg           linkCRCCfg;

    /**
     * @brief   Configuration Mode: Full or Minimal
     */
    MMWave_ConfigurationMode    cfgMode;

}MMWave_InitCfg;

/**
 * @brief
 *  Initial Configuration
 *
 * @details
 *  The structure specifies the configuration required for Programmable Filter configuration.
 *
 */
typedef struct MMWave_FilterCfg_t
{
    rlRfProgFiltCoeff_t         coeffRam;
    rlRfProgFiltConf_t          filtConf[MMWAVE_MAX_PROFILE];

}MMWave_FiltCfg;


/**
@}
*/

/***********************************************************************************************
 * mmWave Exported API:
 ***********************************************************************************************/
extern MMWave_Handle MMWave_init (MMWave_InitCfg* ptrCtrlInitCfg, int32_t* errCode);
extern int32_t MMWave_deinit (MMWave_Handle mmWaveHandle, int32_t* errCode);
extern int32_t MMWave_open (MMWave_Handle mmWaveHandle, const MMWave_OpenCfg* ptrOpenCfg, MMWave_CalibrationData *ptrCalibrationData, int32_t* errCode);
extern int32_t MMWave_close(MMWave_Handle mmWaveHandle, int32_t* errCode);
extern int32_t MMWave_config (MMWave_Handle mmWaveHandle, MMWave_CtrlCfg* ptrControlCfg, int32_t* errCode);
extern int32_t MMWave_start (MMWave_Handle mmWaveHandle, const MMWave_CalibrationCfg* ptrCalibrationCfg, int32_t* errCode);
extern int32_t MMWave_stop (MMWave_Handle mmWaveHandle, int32_t* errCode);
extern int32_t MMWave_execute (MMWave_Handle mmWaveHandle, int32_t* errCode);
extern int32_t MMWave_sync (MMWave_Handle mmWaveHandle, int32_t* errCode);
/***********************************************************************************************
 * Configuration Management API: Available in FULL configuration mode
 ***********************************************************************************************/
extern MMWave_ChirpHandle MMWave_addChirp (MMWave_ProfileHandle profileHandle, const rlChirpCfg_t* ptrChirpCfg, int32_t* errCode);
extern int32_t MMWave_delChirp(MMWave_ProfileHandle profileHandle, MMWave_ChirpHandle chirpHandle, int32_t* errCode);
extern int32_t MMWave_getChirpCfg(MMWave_ChirpHandle chirpHandle, rlChirpCfg_t* ptrChirpCfg,int32_t* errCode);
extern MMWave_ProfileHandle MMWave_addProfile (MMWave_Handle mmWaveHandle, const rlProfileCfg_t* ptrProfileCfg, int32_t* errCode);
extern int32_t MMWave_getNumProfiles(MMWave_Handle mmWaveHandle, uint32_t* numProfiles, int32_t* errCode);
extern int32_t MMWave_getProfileHandle(MMWave_Handle mmWaveHandle,uint8_t profileId, MMWave_ProfileHandle* profileHandle,int32_t* errCode);
extern int32_t MMWave_delProfile (MMWave_Handle mmWaveHandle,MMWave_ProfileHandle profileHandle, int32_t* errCode);
extern int32_t MMWave_getProfileCfg (MMWave_ProfileHandle profileHandle, rlProfileCfg_t* ptrProfileCfg, int32_t* errCode);
extern int32_t MMWave_getNumChirps(MMWave_ProfileHandle profileHandle, uint32_t* numChirps, int32_t* errCode);
extern int32_t MMWave_getChirpHandle(MMWave_ProfileHandle profileHandle, uint32_t chirpIndex, MMWave_ChirpHandle* chirpHandle, int32_t* errCode);
extern MMWave_AdvChirpHandle MMWave_addAdvChirpParam (MMWave_Handle mmWaveHandle, const rlAdvChirpCfg_t* ptrAdvChirpCfg, int32_t* errCode);
extern MMWave_LUTDataHandle MMWave_addAdvChirpLUTData (MMWave_AdvChirpHandle advChirpHandle, const rlInt32_t* ptrLutData, int32_t* errCode);
extern int32_t MMWave_getNumAdvChirpParams(MMWave_Handle mmWaveHandle, uint32_t* numAdvChirpCfgParams, int32_t* errCode);
extern int32_t MMWave_getAdvChirpHandle(MMWave_Handle mmWaveHandle, uint32_t advChirpParamIndex, MMWave_AdvChirpHandle* advChirpHandle, int32_t* errCode);
extern int32_t MMWave_delAdvChirp (MMWave_Handle mmWaveHandle,MMWave_AdvChirpHandle advChirpHandle, int32_t* errCode);
extern int32_t MMWave_getAdvChirpParams(MMWave_AdvChirpHandle advChirpHandle, rlAdvChirpCfg_t* ptrAdvChirpCfg, int32_t* errCode);
extern int32_t MMWave_getLUTData(MMWave_AdvChirpHandle advChirpHandle, rlInt32_t** ptrLUTData, int32_t* errCode);
extern MMWave_BpmChirpHandle MMWave_addBpmChirp (MMWave_Handle mmWaveHandle, const rlBpmChirpCfg_t* ptrBpmChirp, int32_t* errCode);
extern int32_t MMWave_getNumBpmChirp(MMWave_Handle mmWaveHandle, uint32_t* numBpmChirps, int32_t* errCode);
extern int32_t MMWave_getBpmChirpHandle(MMWave_Handle mmWaveHandle,uint32_t bpmChirpIndex,MMWave_BpmChirpHandle* bpmChirpHandle,int32_t* errCode);
extern int32_t MMWave_delBpmChirp (MMWave_Handle mmWaveHandle,MMWave_BpmChirpHandle bpmChirpHandle, int32_t* errCode);
extern int32_t MMWave_getBpmChirpCfg (MMWave_BpmChirpHandle bpmChirpHandle, rlBpmChirpCfg_t* ptrBpmChirp, int32_t* errCode);

extern MMWave_PhaseShiftChirpHandle MMWave_addPhaseShiftChirp (MMWave_Handle mmWaveHandle, const rlRfPhaseShiftCfg_t* ptrPhaseShiftChirp, int32_t* errCode);
extern int32_t MMWave_getNumPhaseShiftChirp(MMWave_Handle mmWaveHandle, uint32_t* numPhaseShiftChirp, int32_t* errCode);
extern int32_t MMWave_getPhaseShiftChirpHandle(MMWave_Handle mmWaveHandle,uint32_t phaseShiftChirpIndex,MMWave_PhaseShiftChirpHandle* phaseShiftChirpHandle,int32_t* errCode);
extern int32_t MMWave_delPhaseShiftChirp (MMWave_Handle mmWaveHandle,MMWave_PhaseShiftChirpHandle phaseShiftChirpHandle, int32_t* errCode);
extern int32_t MMWave_getPhaseShiftChirpCfg (MMWave_PhaseShiftChirpHandle phaseShiftChirpHandle, rlRfPhaseShiftCfg_t* ptrPhaseShiftChirp, int32_t* errCode);

extern int32_t MMWave_flushCfg(MMWave_Handle mmWaveHandle, int32_t* errCode);

/* Error Management API: */
extern void MMWave_decodeError (int32_t errCode, MMWave_ErrorLevel* errorLevel, int16_t* mmWaveError, int16_t* subSysError);

#ifdef __cplusplus
}
#endif

#endif /* MMWAVE_H */
